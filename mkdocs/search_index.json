{
    "docs": [
        {
            "location": "/",
            "text": "What is ConFindr?\n\n\nConFindr is a pipeline that can detect contamination in bacterial NGS data, both between and within species. It can do this with exceptional sensitivity - two samples mixed together with as few as 500 SNPs between them (> 99.9 percent identity!) can be identified. This allows for stringent quality control of NGS samples.\n\n\nHow Does ConFindr Work?\n\n\nBrief Overview\n\n\nADD IMAGE HERE EVENTUALLY\n\n\nConFindr works by looking at rMLST genes. These 53 genes are known to be single copy and conserved across all bacteria, making them excellent markers. As they are known to be single copy (with some caveats), any sample that has multiple alleles of one or more rMLST gene is likely to be contaminated. To identify the presence of multiple alleles in a sample, the following workflow is followed:\n\n\n\n\nDetermine the genus of each sample so that genus-specific rMLST databases can be constructed.\n\n\nPerform stringent quality trimming and bait out reads that contain rMLST gene sequence, using BBDuk.\n\n\nSubsample rMLST reads to a depth of approximately 20X.\n\n\nSplit reads into kmers using jellyfish - typically to a size of k=31. \n\n\nCompare all of the kmers found to all other kmers found, looking for pairs of kmers that differ only by one substitution - these are assumed to represent multiple alleles of the same gene.\n\n\nRepeat steps 3-5 a few times (typically 5) and take the median number of contaminating kmers from these repetitions.\n\n\nUse Mash to do a quick check for cross-species contamination.\n\n\n\n\nDetailed Overview & FAQ\n\n\nWhy Subsample Reads?\n\n\nIn our testing, the coverage depth of samples we tested varied wildly. Some samples had as little coverage as 20-30X, while others were well over 200X. We found that samples with very high coverage (over 100X) frequently had false positive results coming up, as some kmers were present often enough due to sequencing error to look like another allele was present. Enforcing a higher cutoff for number of kmers present on the high depth samples caused drastic cuts to sensitivity. Subsampling reads to 20X coverage prevents sequencing errors while maintaining good sensitivity.\n\n\nWhy Not Just Map Reads to the rMLST Database?\n\n\nThe obvious way to approach this problem would be to map reads to the rMLST database and look for hits to multiple alleles of the same gene. This approach was attempted in early iterations of the pipeline, but was found to work fairly poorly. The issue here was that many rMLST alleles are similar enough that the same read will map to many of them. Because of this, we would often only have one or two reads that mapped unambiguously to rMLST genes across a sample - not enough to reliably call contamination.",
            "title": "Home"
        },
        {
            "location": "/#what-is-confindr",
            "text": "ConFindr is a pipeline that can detect contamination in bacterial NGS data, both between and within species. It can do this with exceptional sensitivity - two samples mixed together with as few as 500 SNPs between them (> 99.9 percent identity!) can be identified. This allows for stringent quality control of NGS samples.",
            "title": "What is ConFindr?"
        },
        {
            "location": "/#how-does-confindr-work",
            "text": "Brief Overview  ADD IMAGE HERE EVENTUALLY  ConFindr works by looking at rMLST genes. These 53 genes are known to be single copy and conserved across all bacteria, making them excellent markers. As they are known to be single copy (with some caveats), any sample that has multiple alleles of one or more rMLST gene is likely to be contaminated. To identify the presence of multiple alleles in a sample, the following workflow is followed:   Determine the genus of each sample so that genus-specific rMLST databases can be constructed.  Perform stringent quality trimming and bait out reads that contain rMLST gene sequence, using BBDuk.  Subsample rMLST reads to a depth of approximately 20X.  Split reads into kmers using jellyfish - typically to a size of k=31.   Compare all of the kmers found to all other kmers found, looking for pairs of kmers that differ only by one substitution - these are assumed to represent multiple alleles of the same gene.  Repeat steps 3-5 a few times (typically 5) and take the median number of contaminating kmers from these repetitions.  Use Mash to do a quick check for cross-species contamination.   Detailed Overview & FAQ  Why Subsample Reads?  In our testing, the coverage depth of samples we tested varied wildly. Some samples had as little coverage as 20-30X, while others were well over 200X. We found that samples with very high coverage (over 100X) frequently had false positive results coming up, as some kmers were present often enough due to sequencing error to look like another allele was present. Enforcing a higher cutoff for number of kmers present on the high depth samples caused drastic cuts to sensitivity. Subsampling reads to 20X coverage prevents sequencing errors while maintaining good sensitivity.  Why Not Just Map Reads to the rMLST Database?  The obvious way to approach this problem would be to map reads to the rMLST database and look for hits to multiple alleles of the same gene. This approach was attempted in early iterations of the pipeline, but was found to work fairly poorly. The issue here was that many rMLST alleles are similar enough that the same read will map to many of them. Because of this, we would often only have one or two reads that mapped unambiguously to rMLST genes across a sample - not enough to reliably call contamination.",
            "title": "How Does ConFindr Work?"
        },
        {
            "location": "/install/",
            "text": "System Requirements\n\n\nConFindr has been tested with Debian-based Linux systems, but should in principle work on any flavour of Linux, as well as MacOSX. Windows is not supported at this time,\nbut Windows users may be able to use the ConFindr Docker image in order to run ConFindr.\n\n\nTo run ConFindr, your PC should have a minimum of 8GB of RAM, and at least 10GB of disk space. Any number of processors will work, with more generally being better.\n\n\nDownloading ConFindr Databases\n\n\nThe databases necessary for making ConFindr run are available for download from FigShare. \nThese databases must be downloaded, no matter which install method you choose to use.\n\n\nNavigate to the place you would like to download the database, and use the following commands to download and uncompress the folder:\n\n\nwget https://ndownloader.figshare.com/files/11864267 && tar xf 11864267 && rm 11864267\n\n\nThese commands should create a folder called \ndatabases\n in your current working directory. This folder contains everything you need to run ConFindr - it's what will be specified with the \n-d\n option.\n\n\nInstalling Using Conda (Recommended)\n\n\nThe easiest way to install the ConFindr script and all of its dependencies is using conda. If you don't already have conda installed, instructions can be found \non the conda ReadTheDocs page\n.\n\n\nWith conda installed, all you'll need to do is download the ConFindr environment, which as been uploaded to the Anaconda cloud. To do this, use this command:\n\n\nconda env create lowandrew/confindr\n\n\nYou should then be able to enter the conda environment:\n\n\nsource activate confindr\n\n\nWithin the environment, typing \nconfindr.py\n will bring access the ConFindr pipeline. See the \nUsage\n section for instructions on how to use ConFindr, including a ConFindr run on an example dataset.\n\n\nInstalling Using Docker\n\n\nConFindr can also be used via Docker, which will take care of installing all of ConFindr's dependencies for you. If you do not have Docker installed, instructions on how to install it\ncan be found \nhere\n.\n\n\nWith Docker installed, all you have to do to install ConFindr is enter the following command, which will pull the ConFindr image from the Docker Hub and put it on your machine:\n\n\ndocker pull olcbioinformatics/confindr\n\n\nYou can verify that the pull was successful by entering the command \ndocker images\n. You should see \nolcbioinformatics/confindr\n in the list. For instructions on using the image, see \nthe \nUsage\n section.\n\n\nManual Install Using Pip\n\n\nExecutable\n\n\nConFindr can also be installed using pip. Use of a virtual environment for ConFindr is highly recommended. To create a virtualenv:\n\n\n\n\nCreate an empty directory (i.e. \nmkdir ~/Virtual_Environments/ConFindr\n)\n\n\nVirtualenv that directory (\nvirtualenv -p /usr/bin/python3 ~/Virtual_Environments/ConFindr\n)\n\n\nActivate the virtualenv (\nsource ~/Virtual_Environments/ConFindr/bin/activate\n)\n\n\nInstall ConFindr - this should also install any packages that ConFindr depends on (\npip install confindr\n)\n\n\n\n\nWith this done, you'll need to make sure that any necessary dependencies are installed.\n\n\nDependencies\n\n\nBefore using ConFindr, you'll need to download and add the following programs to your $PATH:\n\n\n\n\nBBTools (>=37.23)\n\n\nJellyfish (>= 2.2.6)\n\n\nNCBI BLAST+ (>=2.2.31\n\n\nMash (>=2.0)\n\n\nPython (>=3.5)\n\n\n\n\nInstructions on adding programs to your $PATH can be found \nhere\n.\n\n\nIf ConFindr can't find these dependencies when you try to run it, you will see an error message. ConFindr will continue to attempt to run, but will likely crash at some point in the process.",
            "title": "Installation"
        },
        {
            "location": "/install/#system-requirements",
            "text": "ConFindr has been tested with Debian-based Linux systems, but should in principle work on any flavour of Linux, as well as MacOSX. Windows is not supported at this time,\nbut Windows users may be able to use the ConFindr Docker image in order to run ConFindr.  To run ConFindr, your PC should have a minimum of 8GB of RAM, and at least 10GB of disk space. Any number of processors will work, with more generally being better.",
            "title": "System Requirements"
        },
        {
            "location": "/install/#downloading-confindr-databases",
            "text": "The databases necessary for making ConFindr run are available for download from FigShare.  These databases must be downloaded, no matter which install method you choose to use.  Navigate to the place you would like to download the database, and use the following commands to download and uncompress the folder:  wget https://ndownloader.figshare.com/files/11864267 && tar xf 11864267 && rm 11864267  These commands should create a folder called  databases  in your current working directory. This folder contains everything you need to run ConFindr - it's what will be specified with the  -d  option.",
            "title": "Downloading ConFindr Databases"
        },
        {
            "location": "/install/#installing-using-conda-recommended",
            "text": "The easiest way to install the ConFindr script and all of its dependencies is using conda. If you don't already have conda installed, instructions can be found  on the conda ReadTheDocs page .  With conda installed, all you'll need to do is download the ConFindr environment, which as been uploaded to the Anaconda cloud. To do this, use this command:  conda env create lowandrew/confindr  You should then be able to enter the conda environment:  source activate confindr  Within the environment, typing  confindr.py  will bring access the ConFindr pipeline. See the  Usage  section for instructions on how to use ConFindr, including a ConFindr run on an example dataset.",
            "title": "Installing Using Conda (Recommended)"
        },
        {
            "location": "/install/#installing-using-docker",
            "text": "ConFindr can also be used via Docker, which will take care of installing all of ConFindr's dependencies for you. If you do not have Docker installed, instructions on how to install it\ncan be found  here .  With Docker installed, all you have to do to install ConFindr is enter the following command, which will pull the ConFindr image from the Docker Hub and put it on your machine:  docker pull olcbioinformatics/confindr  You can verify that the pull was successful by entering the command  docker images . You should see  olcbioinformatics/confindr  in the list. For instructions on using the image, see \nthe  Usage  section.",
            "title": "Installing Using Docker"
        },
        {
            "location": "/install/#manual-install-using-pip",
            "text": "Executable  ConFindr can also be installed using pip. Use of a virtual environment for ConFindr is highly recommended. To create a virtualenv:   Create an empty directory (i.e.  mkdir ~/Virtual_Environments/ConFindr )  Virtualenv that directory ( virtualenv -p /usr/bin/python3 ~/Virtual_Environments/ConFindr )  Activate the virtualenv ( source ~/Virtual_Environments/ConFindr/bin/activate )  Install ConFindr - this should also install any packages that ConFindr depends on ( pip install confindr )   With this done, you'll need to make sure that any necessary dependencies are installed.  Dependencies  Before using ConFindr, you'll need to download and add the following programs to your $PATH:   BBTools (>=37.23)  Jellyfish (>= 2.2.6)  NCBI BLAST+ (>=2.2.31  Mash (>=2.0)  Python (>=3.5)   Instructions on adding programs to your $PATH can be found  here .  If ConFindr can't find these dependencies when you try to run it, you will see an error message. ConFindr will continue to attempt to run, but will likely crash at some point in the process.",
            "title": "Manual Install Using Pip"
        },
        {
            "location": "/usage/",
            "text": "Usage with a Pip/Conda Install\n\n\nIf you used pip or conda to install, all you need to do is activate your ConFindr virtualenv/type \nconfindr.py\n on the command line. Doing so without providing parameters will give a message telling you what parameters you do need to provide.\n\n\nExample Dataset\n\n\nAn example dataset has been uploaded to FigShare. You can download it to your current working directory with the following command:\n\n\nwget https://ndownloader.figshare.com/files/9972709 && tar xf 9972709\n\n\nThis example dataset contains two different serotypes of \nEscherichia coli\n mixed together - it's about 80/20 split of O103 and O157. Contamination like this is difficult to detect\nwith regular tools - it's possible to pick up that it's two different strains, but it can be finicky. ConFindr, however, has no difficulty picking up the fact that this sample is contaminated.\n\n\nIn order to have ConFindr analyze this sample, the parameters you need to provide are:\n\n\n\n\n-i, --input_directory\n: The path to a directory containing the reads, in FASTQ format, that you want analyzed. If you're using the example dataset, you'll want to enter \nexample-data\n\n\n-o, --output_name\n: The base name for your output. If you put \noutput\n for this parameter, a folder called \noutput\n will be created, and a file called \nconfindr_report.csv\n with contamination\ninformation will be created in this folder\n\n\n-d, ---databases\n: The path to the databases directory obtained when downloading the \ndatabases\n folder from FigShare.\n\n\n\n\nSo, if the \ndatabases\n and \nexample-data\n folders were downloaded to your current working directory and you want to have an output folder called \noutput\n, the command to run ConFindr would be:\n\n\nconfindr.py -i example-data -o output -d databases\n\n\nYou can use absolute or relative paths, and trailing slashes are also acceptable for the directories specified. If ConFindr is properly installed, you should see something similar to the following appear on your terminal:\n\n\n [Elapsed Time: 0.00 seconds] Determining genus of each sample... \n\n\n\n [Elapsed Time: 14.38 seconds] Beginning analysis of sample example...\n\n [Elapsed Time: 0.00 seconds] Extracting rMLST genes... \n [Elapsed Time: 19.88 seconds] Quality trimming... \n [Elapsed Time: 20.43 seconds] Beginning 5 cycles of contamination detection... \n [Elapsed Time: 20.43 seconds] Working on cycle 1 of 5... \n [Elapsed Time: 30.40 seconds] Working on cycle 2 of 5... \n [Elapsed Time: 41.05 seconds] Working on cycle 3 of 5... \n [Elapsed Time: 52.03 seconds] Working on cycle 4 of 5... \n [Elapsed Time: 63.27 seconds] Working on cycle 5 of 5... \n [Elapsed Time: 73.72 seconds] Finding cross contamination... \n [Elapsed Time: 84.94 seconds] Finished analysis of sample example! \n\n\n\n\nThe run shouldn't take too long - depending on how powerful your machine is, it will most likely take 2 or 3 minutes. Once the run is done, you'll be able to inspect your results.\nThe \nContamStatus\n column should read \nTrue\n, and the \nNumContamSNVs\n column should have a value somewhere around 40.\n\n\nUsage with a Docker Install\n\n\nIf you used Docker to install ConFindr, usage will be slightly different. Assuming you have the \ndatabases\n from the \nInstallation\n step and \nexample-data\n from above in your current working\ndirectory, the command to run ConFindr would be:\n\n\ndocker run -it -v /path/to/current/directory/:/data olcbioinformatics/confindr confindr.py -i /data/example-data -o /data/output -d /data/databases\n\n\nYou should see the same output to the terminal that was mentioned above, and have the same output files in a folder called \noutput\n in your current working directory.\n\n\nInterpreting ConFindr Results\n\n\nThe results file that ConFindr produces is in comma-separated value (CSV) format, which can be opened by any spreadsheet application (Excel, LibreOffice, etc.) or your favorite text editor.\n\n\nThe file has the following headers: Sample, Genus, NumContamSNVs, NumUniqueKmers, CrossContamination, and ContamStatus. Of these, ContamStatus is the most important - it will be \nTrue\n if a sample\nis contaminated, and \nFalse\n if a sample is not contaminated. Detailed descriptions of each header follow.\n\n\n\n\nSample\n: The name of the sample. ConFindr will take everything before the first underscore (_) character to be the name of the sample, as done with samples coming from an Illumina MiSeq.\n\n\nGenus\n: The genus that ConFindr thinks your sample is. If ConFindr couldn't figure out what genus your sample is from, this will be NA.\n\n\nNumContamSNVs\n: The number of times ConFindr found a kmer that had a mismatch, indicating the potential for multiple alleles of one gene being present. Completely clean samples should have a value of 0.\n\n\nNumUniqueKmers\n: The number of unique kmers found by ConFindr for a sample. Numbers substantially above the total length of the rMLST genes (~35000 base pairs) can indicate contamination.\n\n\nCrossContamination\n: If ConFindr has detected contamination due to multiple genera being present, this is where you'll see it, in the form of a list of genera present separated by colons. If only one\ngenus is present in the sample, this column will read \nNA\n.\n\n\nContamStatus\n: The most important of all! Will read \nTrue\n if contamination is present in the sample, and \nFalse\n if contamination is not present. The result will be \nTrue\n if any of the following conditions are met: \n\n\n3 or more contaminating SNVs are found. \n\n\nMore than 40000 unique rMLST kmers are found.\n\n\nThere is cross contamination between genera.\n\n\n\n\n\n\n\n\nOptional Arguments\n\n\nConFindr has a few optional arguments that allow you to modify its other parameters. Optional arguments are:\n\n\n\n\n-t, --threads\n: The number of threads to run ConFindr analysis with. The default is to use all threads available on your machine, and ConFindr scales very well with more threads, so it's recommended that this option be left at the default unless you need the computational resources for something else.\n\n\n-n, --number_subsamples\n: The number of times you want ConFindr to sample your rMLST reads to try to detect contamination. By default this is set to 3.\n\n\n-k, --kmer-size\n: The kmer size ConFindr uses to try to detect contamination. Default is 31. Usage with other values may produce very unreliable results and is \nnot\n recommended.\n\n\n-s, --subsample_depth\n: Coverage depth to subsample to. Default value is 20, which provides a good tradeoff between sensitvity and specificity. Going any lower will make it very difficult to detect contamination, and going higher will increase the false positive rate.\n\n\n-c, --kmer_cutoff\n: The cutoff for the number of times a kmer must be seen before it is considered trustworthy and is included in the analysis. By default set to 2. Setting any lower this this essentially guarantees that your analysis will be overrun by false positives called by sequencing errors.\n\n\n-fid, --forward_id\n: The identifier for forward reads in your input FASTQ folder. By default, this is \n_R1\n. If you follow a different naming scheme, this is the parameter to change.\n\n\n-rid, --reverse_id\n: The identifier for reverse reads in your input FASTQ folder. By default, this is \n_R2\n. If you follow a different naming scheme, this is the parameter to change. \n\n\n\n\nGenerally speaking, none of these parameters should be changed; ConFindr has been tested extensively with its default parameters and been found to work very well.",
            "title": "Usage"
        },
        {
            "location": "/usage/#usage-with-a-pipconda-install",
            "text": "If you used pip or conda to install, all you need to do is activate your ConFindr virtualenv/type  confindr.py  on the command line. Doing so without providing parameters will give a message telling you what parameters you do need to provide.",
            "title": "Usage with a Pip/Conda Install"
        },
        {
            "location": "/usage/#example-dataset",
            "text": "An example dataset has been uploaded to FigShare. You can download it to your current working directory with the following command:  wget https://ndownloader.figshare.com/files/9972709 && tar xf 9972709  This example dataset contains two different serotypes of  Escherichia coli  mixed together - it's about 80/20 split of O103 and O157. Contamination like this is difficult to detect\nwith regular tools - it's possible to pick up that it's two different strains, but it can be finicky. ConFindr, however, has no difficulty picking up the fact that this sample is contaminated.  In order to have ConFindr analyze this sample, the parameters you need to provide are:   -i, --input_directory : The path to a directory containing the reads, in FASTQ format, that you want analyzed. If you're using the example dataset, you'll want to enter  example-data  -o, --output_name : The base name for your output. If you put  output  for this parameter, a folder called  output  will be created, and a file called  confindr_report.csv  with contamination\ninformation will be created in this folder  -d, ---databases : The path to the databases directory obtained when downloading the  databases  folder from FigShare.   So, if the  databases  and  example-data  folders were downloaded to your current working directory and you want to have an output folder called  output , the command to run ConFindr would be:  confindr.py -i example-data -o output -d databases  You can use absolute or relative paths, and trailing slashes are also acceptable for the directories specified. If ConFindr is properly installed, you should see something similar to the following appear on your terminal:   [Elapsed Time: 0.00 seconds] Determining genus of each sample... \n\n\n\n [Elapsed Time: 14.38 seconds] Beginning analysis of sample example...\n\n [Elapsed Time: 0.00 seconds] Extracting rMLST genes... \n [Elapsed Time: 19.88 seconds] Quality trimming... \n [Elapsed Time: 20.43 seconds] Beginning 5 cycles of contamination detection... \n [Elapsed Time: 20.43 seconds] Working on cycle 1 of 5... \n [Elapsed Time: 30.40 seconds] Working on cycle 2 of 5... \n [Elapsed Time: 41.05 seconds] Working on cycle 3 of 5... \n [Elapsed Time: 52.03 seconds] Working on cycle 4 of 5... \n [Elapsed Time: 63.27 seconds] Working on cycle 5 of 5... \n [Elapsed Time: 73.72 seconds] Finding cross contamination... \n [Elapsed Time: 84.94 seconds] Finished analysis of sample example!   The run shouldn't take too long - depending on how powerful your machine is, it will most likely take 2 or 3 minutes. Once the run is done, you'll be able to inspect your results.\nThe  ContamStatus  column should read  True , and the  NumContamSNVs  column should have a value somewhere around 40.",
            "title": "Example Dataset"
        },
        {
            "location": "/usage/#usage-with-a-docker-install",
            "text": "If you used Docker to install ConFindr, usage will be slightly different. Assuming you have the  databases  from the  Installation  step and  example-data  from above in your current working\ndirectory, the command to run ConFindr would be:  docker run -it -v /path/to/current/directory/:/data olcbioinformatics/confindr confindr.py -i /data/example-data -o /data/output -d /data/databases  You should see the same output to the terminal that was mentioned above, and have the same output files in a folder called  output  in your current working directory.",
            "title": "Usage with a Docker Install"
        },
        {
            "location": "/usage/#interpreting-confindr-results",
            "text": "The results file that ConFindr produces is in comma-separated value (CSV) format, which can be opened by any spreadsheet application (Excel, LibreOffice, etc.) or your favorite text editor.  The file has the following headers: Sample, Genus, NumContamSNVs, NumUniqueKmers, CrossContamination, and ContamStatus. Of these, ContamStatus is the most important - it will be  True  if a sample\nis contaminated, and  False  if a sample is not contaminated. Detailed descriptions of each header follow.   Sample : The name of the sample. ConFindr will take everything before the first underscore (_) character to be the name of the sample, as done with samples coming from an Illumina MiSeq.  Genus : The genus that ConFindr thinks your sample is. If ConFindr couldn't figure out what genus your sample is from, this will be NA.  NumContamSNVs : The number of times ConFindr found a kmer that had a mismatch, indicating the potential for multiple alleles of one gene being present. Completely clean samples should have a value of 0.  NumUniqueKmers : The number of unique kmers found by ConFindr for a sample. Numbers substantially above the total length of the rMLST genes (~35000 base pairs) can indicate contamination.  CrossContamination : If ConFindr has detected contamination due to multiple genera being present, this is where you'll see it, in the form of a list of genera present separated by colons. If only one\ngenus is present in the sample, this column will read  NA .  ContamStatus : The most important of all! Will read  True  if contamination is present in the sample, and  False  if contamination is not present. The result will be  True  if any of the following conditions are met:   3 or more contaminating SNVs are found.   More than 40000 unique rMLST kmers are found.  There is cross contamination between genera.",
            "title": "Interpreting ConFindr Results"
        },
        {
            "location": "/usage/#optional-arguments",
            "text": "ConFindr has a few optional arguments that allow you to modify its other parameters. Optional arguments are:   -t, --threads : The number of threads to run ConFindr analysis with. The default is to use all threads available on your machine, and ConFindr scales very well with more threads, so it's recommended that this option be left at the default unless you need the computational resources for something else.  -n, --number_subsamples : The number of times you want ConFindr to sample your rMLST reads to try to detect contamination. By default this is set to 3.  -k, --kmer-size : The kmer size ConFindr uses to try to detect contamination. Default is 31. Usage with other values may produce very unreliable results and is  not  recommended.  -s, --subsample_depth : Coverage depth to subsample to. Default value is 20, which provides a good tradeoff between sensitvity and specificity. Going any lower will make it very difficult to detect contamination, and going higher will increase the false positive rate.  -c, --kmer_cutoff : The cutoff for the number of times a kmer must be seen before it is considered trustworthy and is included in the analysis. By default set to 2. Setting any lower this this essentially guarantees that your analysis will be overrun by false positives called by sequencing errors.  -fid, --forward_id : The identifier for forward reads in your input FASTQ folder. By default, this is  _R1 . If you follow a different naming scheme, this is the parameter to change.  -rid, --reverse_id : The identifier for reverse reads in your input FASTQ folder. By default, this is  _R2 . If you follow a different naming scheme, this is the parameter to change.    Generally speaking, none of these parameters should be changed; ConFindr has been tested extensively with its default parameters and been found to work very well.",
            "title": "Optional Arguments"
        }
    ]
}